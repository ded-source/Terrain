// Code generated by AI (Claude Sonnet 4 by Anthropic)
using UnityEngine;
using UnityEngine.InputSystem;

public class FirstPersonCameraController : MonoBehaviour
{
    [Header("Movement Settings")]
    [SerializeField] private float moveSpeed = 5f;
    [SerializeField] private float fastMoveSpeed = 10f;
    [SerializeField] private float slowMoveSpeed = 2f;

    [Header("Look Settings")]
    [SerializeField] private float mouseSensitivity = 2f;
    [SerializeField] private bool invertY = false;

    [Header("Vertical Look Limits")]
    [SerializeField] private float minLookAngle = -90f;
    [SerializeField] private float maxLookAngle = 90f;

    [Header("Movement Smoothing")]
    [SerializeField] private float movementSmoothing = 10f;
    [SerializeField] private float lookSmoothing = 10f;

    [Header("Debug")]
    [SerializeField] private bool showDebugInfo = false;

    private Camera cam;
    private Vector3 currentVelocity;
    private Vector3 targetVelocity;
    private float currentXRotation = 0f;
    private float targetXRotation = 0f;
    private float currentYRotation = 0f;
    private float targetYRotation = 0f;

    // Input System references
    private Mouse mouse;
    private Keyboard keyboard;
    private Vector2 lookInput;
    private Vector3 moveInput;
    private bool isLooking = false;

    void Start()
    {
        Initialize();
    }

    void Initialize()
    {
        cam = GetComponent<Camera>();
        if (cam == null)
        {
            Debug.LogError("FirstPersonCameraController requires a Camera component!");
            return;
        }

        // Initialize Input System
        mouse = Mouse.current;
        keyboard = Keyboard.current;

        if (mouse == null)
        {
            Debug.LogError("No mouse detected!");
            return;
        }

        if (keyboard == null)
        {
            Debug.LogError("No keyboard detected!");
            return;
        }

        // Initialize rotation values from current transform
        Vector3 currentEuler = transform.eulerAngles;
        currentYRotation = targetYRotation = currentEuler.y;
        currentXRotation = targetXRotation = currentEuler.x;

        // Normalize X rotation to -180 to 180 range
        if (currentXRotation > 180f)
            currentXRotation = targetXRotation = currentXRotation - 360f;
    }

    void Update()
    {
        if (mouse == null || keyboard == null) return;

        HandleInput();
        UpdateMovement();
        UpdateLook();

        if (showDebugInfo)
        {
            Debug.Log($"Move Input: {moveInput}, Look Input: {lookInput}, Is Looking: {isLooking}");
        }
    }

    void HandleInput()
    {
        // Movement input (WASD + QE for up/down)
        Vector3 inputVector = Vector3.zero;

        if (keyboard.wKey.isPressed) inputVector.z += 1f;
        if (keyboard.sKey.isPressed) inputVector.z -= 1f;
        if (keyboard.aKey.isPressed) inputVector.x -= 1f;
        if (keyboard.dKey.isPressed) inputVector.x += 1f;
        if (keyboard.eKey.isPressed) inputVector.y += 1f; // Up
        if (keyboard.qKey.isPressed) inputVector.y -= 1f; // Down

        moveInput = inputVector.normalized;

        // Look input - only when right mouse button is held (like Unity Editor)
        if (mouse.rightButton.wasPressedThisFrame)
        {
            isLooking = true;
            // Lock cursor for smooth looking
            Cursor.lockState = CursorLockMode.Locked;
            Cursor.visible = false;
        }
        else if (mouse.rightButton.wasReleasedThisFrame)
        {
            isLooking = false;
            // Unlock cursor
            Cursor.lockState = CursorLockMode.None;
            Cursor.visible = true;
        }

        if (isLooking)
        {
            lookInput = mouse.delta.ReadValue();
        }
        else
        {
            lookInput = Vector2.zero;
        }
    }

    void UpdateMovement()
    {
        // Determine movement speed based on modifiers
        float currentMoveSpeed = moveSpeed;

        if (keyboard.leftShiftKey.isPressed || keyboard.rightShiftKey.isPressed)
        {
            currentMoveSpeed = fastMoveSpeed;
        }
        else if (keyboard.leftCtrlKey.isPressed || keyboard.rightCtrlKey.isPressed)
        {
            currentMoveSpeed = slowMoveSpeed;
        }

        // Calculate target velocity in world space
        Vector3 forward = transform.forward;
        Vector3 right = transform.right;
        Vector3 up = Vector3.up; // Always use world up for vertical movement

        targetVelocity = (forward * moveInput.z + right * moveInput.x + up * moveInput.y) * currentMoveSpeed;

        // Smooth movement
        currentVelocity = Vector3.Lerp(currentVelocity, targetVelocity, movementSmoothing * Time.deltaTime);

        // Apply movement
        transform.position += currentVelocity * Time.deltaTime;
    }

    void UpdateLook()
    {
        if (!isLooking) return;

        // Calculate rotation deltas
        float deltaYaw = lookInput.x * mouseSensitivity;
        float deltaPitch = lookInput.y * mouseSensitivity;

        if (invertY)
            deltaPitch = -deltaPitch;
        else
            deltaPitch = -deltaPitch; // Default Unity behavior is inverted

        // Update target rotations
        targetYRotation += deltaYaw;
        targetXRotation += deltaPitch;

        // Clamp vertical look
        targetXRotation = Mathf.Clamp(targetXRotation, minLookAngle, maxLookAngle);

        // Smooth rotation
        currentYRotation = Mathf.LerpAngle(currentYRotation, targetYRotation, lookSmoothing * Time.deltaTime);
        currentXRotation = Mathf.LerpAngle(currentXRotation, targetXRotation, lookSmoothing * Time.deltaTime);

        // Apply rotation
        transform.rotation = Quaternion.Euler(currentXRotation, currentYRotation, 0f);
    }

    // Public methods for external control
    public void SetPosition(Vector3 position)
    {
        transform.position = position;
        currentVelocity = Vector3.zero;
        targetVelocity = Vector3.zero;
    }

    public void SetRotation(Vector3 eulerAngles)
    {
        transform.rotation = Quaternion.Euler(eulerAngles);
        currentYRotation = targetYRotation = eulerAngles.y;
        currentXRotation = targetXRotation = eulerAngles.x;

        // Normalize X rotation
        if (currentXRotation > 180f)
            currentXRotation = targetXRotation = currentXRotation - 360f;
    }

    public void SetMoveSpeed(float speed)
    {
        moveSpeed = speed;
    }

    public void SetMouseSensitivity(float sensitivity)
    {
        mouseSensitivity = sensitivity;
    }

    public bool IsMoving()
    {
        return currentVelocity.magnitude > 0.1f;
    }

    public bool IsLooking()
    {
        return isLooking;
    }

    void OnDisable()
    {
        // Make sure cursor is unlocked when script is disabled
        if (isLooking)
        {
            Cursor.lockState = CursorLockMode.None;
            Cursor.visible = true;
        }
    }

    void OnApplicationFocus(bool hasFocus)
    {
        // Handle focus loss gracefully
        if (!hasFocus && isLooking)
        {
            Cursor.lockState = CursorLockMode.None;
            Cursor.visible = true;
        }
    }
}