# Unity Clipmap Terrain Renderer

AI was used in development of this project, and the below project description was generated by AI. See [AI-Assisted Development](#ai-assisted-development)

![Screenshot](ReadmeResources/View1.png)

[Video Fly-around (YouTube)](https://www.youtube.com/watch?v=uqFCjqqZKhA)

A high-performance Unity terrain rendering system designed for large-scale terrains using clipmaps and adaptive level-of-detail (LOD).

## Features

- **Large Terrain Support**: Renders large terrains with configurable size. The terrain used for development is ~65km^2 with albedo and height map resolutions of 16k^2
- **Clipmap Texture Streaming**: Dynamically loads high-resolution textures based on camera position
- **Adaptive LOD System**: Quadtree-based subdivision provides higher detail near the camera
- **Instanced Rendering**: Efficient GPU rendering using `Graphics.DrawMeshInstanced`
- **Frustum Culling**: Only renders visible terrain tiles
- **Asynchronous Loading**: Non-blocking texture streaming via Unity Addressables
- **Debug Visualization**: Overhead camera and UI panels for clipmap inspection

## Architecture

### Terrain.cs
- Manages the main terrain rendering pipeline
- Implements quadtree-based LOD system with distance-based subdivision
- Handles tile mesh generation and instanced rendering
- Coordinates with clipmap systems for texture data

### Clipmap.cs
- Streams large virtual textures (16k+ resolution) using smaller clip windows (2k)
- Maintains multiple mip levels in a `Texture2DArray`
- Loads texture tiles asynchronously based on camera movement
- Supports both albedo and heightmap data

## Configuration

```csharp
[SerializeField] private float terrainSizeMeters = 8192.0f;    // Total terrain size
[SerializeField] private float tileSizeMeters = 64.0f;         // Individual tile size
[SerializeField] private int tileQuadCount = 32;               // Quads per tile
[SerializeField] private float lod0Distance = 64.0f;          // Highest detail distance
[SerializeField] private int virtualSize = 16 * 1024;         // Virtual texture size
[SerializeField] private int clipSize = 2048;                 // Clip window size
```

## Usage

1. Attach `Terrain` component to a GameObject
2. Configure clipmap components for albedo and heightmap data
3. Set up Addressable texture assets organized by mip level and tile coordinates
4. Assign cameras and material prefabs
5. The system automatically handles LOD and texture streaming during gameplay

## Texture Organization

Textures should be organized in Addressables with the naming convention:
```
{textureRoot}/Mip_{lod}/tile_{lod}_{x}_{y}.png
```

## Performance

- Efficient for large open-world environments
- Scales well with terrain size due to adaptive LOD
- Memory-efficient texture streaming
- GPU-optimized instanced rendering

## Requirements

- Unity with Addressables package
- Texture2DArray support
- Graphics.DrawMeshInstanced compatibility

## Data source

The source albedo and height maps for the terrain are not included in this repo. They were generated from the following page and post-processed with [mipmap_generator.py](Assets/AI%20Generated/mipmap_generator.py)

https://manticorp.github.io/unrealheightmap/#latitude/40.878218141046545/longitude/-111.64581298828125/zoom/9/outputzoom/15/width/16384/height/16384

## AI-Assisted Development

Claude Sonnet 4 was used to assist with development.

The primary design and logic of core classes such as Terrain.cs, Clipmap.cs, and TerrainShader.shader were human-developed.

Files that were generated by AI:
- [mipmap_generator.py](Assets/AI%20Generated/mipmap_generator.py)
    - Used to process the full size textures into tiles for clipmap rendering.
- [FirstPersonCameraController.cs](Assets/AI%20Generated/FirstPersonCameraController.cs)
    - A camera control script that mimics Unity's Editor camera controls.
- The above description in this README.md was generated by AI by providing a screenshot and the Terrain.cs and Clipmap.cs source files.

AI was also used throughout the project for:
- Assistance with using the Unity API
    - For example, questions such as "How do I do instance rendering in Unity", "How do I setup a Texture2DArray in a shader", etc.
- Generating code snippets
    - For example, the random color generation function used in the debug visualization shader.
- Various prototypes and scripts that are no longer needed and not included in the project.
    - Initially I could only find an STL height map source format, so Claude was used to generate a python conversion script.
    - Initial height map rendering shaders were generated.
    - etc.

I did not have much prior experience with AI-assisted development, so this was an interesting learning exercise.
